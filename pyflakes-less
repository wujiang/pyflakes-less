#!/usr/bin/env python

import os
import sys
import argparse
import StringIO

from pyflakes.api import checkRecursive
from pyflakes.reporter import Reporter
from pyflakes.messages import (
    UndefinedName,
    UndefinedLocal,
    UnusedVariable,
)


def is_message_type(message, message_type):
    """Check if the given message is of the given pyflakes message type. The
    algorithm to check two message are the same type is: they are the
    same type if and only if there are only count("%r") different
    words between std_message and message.

    :param message: a message generated by pyflakes
    :param message_type: a message type from pyflakes.messages,
        i.e.: `UnusedVariable`

    """
    std_message = message_type.message
    std_message = [m.strip() for m in std_message.split() if m.strip()]
    # clean up the message
    message = message.split(": ")[1]
    message = [m.strip() for m in message.split() if m.strip()]

    if len(std_message) != len(message):
        return False

    same = True
    for idx, word in enumerate(std_message):
        if word != "%r" and word != message[idx]:
            same = False
            break

    return same


def main():
    parser = argparse.ArgumentParser(description="Customized Pyflakes")
    parser.add_argument("files", nargs="+", help="files to check")
    args = parser.parse_args()

    warning_stream = StringIO.StringIO()
    error_stream = StringIO.StringIO()

    reporter = Reporter(warning_stream, error_stream)

    warnings = checkRecursive(args.files, reporter)

    # treat some warnings as errors
    #   - Undefined variables
    #   - Unused variables
    #   - Undefined local variables
    message_types = [
        UndefinedName,
        UndefinedLocal,
        UnusedVariable,
    ]

    warning_stream.seek(0)
    error_stream.seek(0)
    warnings = warning_stream.readlines()
    errors = error_stream.readlines()

    for warning in warnings:
        for message_type in message_types:
            if is_message_type(warning, message_type):
                errors.append(warning)
                break

    if errors:
        sys.stdout.write("".join(errors))
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
